
아직까지 내가 생각하는 리액트의 꽃!
배열 렌더링

### 1) .map

배열의 요소를 가공해서 새로운 배열을 만든다.

	배열.map((item) => item으로 가공한 값)


**리액트 활용 예시**

이런 map의 특성을 이용해서 html 객체를 반복 생산할 수 있다.

```JSX
function FoodListItem({ item }) {
  const { imgUrl, title, calorie, content } = item;

  return (
    <div>
      <img src={imgUrl} alt={title} />
      <div>{title}</div>
      <div>{calorie}</div>
      <div>{content}</div>
    </div>
  );
}

function FoodList({ items }) {
  const list = items.map((item) => <li>{item.title}</li>);
  return <ul>{list}</ul>;
}

export default FoodList;
```
컴포넌트를 반복 돌릴 수도 있고, 안에서 배열을 돌려서 React 객체를 반환 할 수도 있고 
무궁무진하다. 

1) **표현식 {}괄호**가 어디에 들어갈 지만 잘 생각하면서 만들자. 
2) 각 요소에 접근을 고려해서 Key(인댁스)를 붙이는 습관을 잊지 말자.

### 2. .Sort

조건에 따라 정렬한다.

	배열.sort((a, b) => /*조건이 참이면 a가 뒤쪽, 거짓이면 앞쪽*/);

## ✅ 기본 동작 (문자열 기준 정렬)

```js
const fruits = ['banana', 'apple', 'cherry'];
fruits.sort();
console.log(fruits); // ['apple', 'banana', 'cherry']
```

- 기본적으로 **문자열의 유니코드 순서**로 정렬된다.
- 숫자를 문자열로 변환한 후 정렬하기 때문에, 숫자 배열 정렬 시 의도와 다르게 동작할 수 있다.

```js
const numbers = [100, 21, 3];
numbers.sort();
console.log(numbers); // [100, 21, 3] → 문자로 간주됨
```

---

## ✅ 숫자 정렬

```js
const numbers = [100, 21, 3];
numbers.sort((a, b) => a - b); // 오름차순
console.log(numbers); // [3, 21, 100]

numbers.sort((a, b) => b - a); // 내림차순
console.log(numbers); // [100, 21, 3]
```
- `a - b`: 오름차순
- `b - a`: 내림차순

a, b는 배열의 두 요소를 의미한다. 배열을 두 요소씩 돌아가며 비교하고 정렬하는 데,
( - ) 연산의 결과값 양, 음, 0 에 따라 정렬 순서를 결정한다.

**리액트 활용 예시**

```JSX
import { useState } from 'react';
import FoodList from './FoodList';
import items from '../mock.json';

function App() {
  const [order, setOrder] = useState('createdAt');

  const handleNewestClick = () => setOrder('createdAt');

  const handleCalorieClick = () => setOrder('calorie');

  const sortedItems = items.sort((a, b) => b[order] - a[order]);

  return (
    <div>
      <button onClick={handleNewestClick}>최신순</button>
      <button onClick={handleCalorieClick}>칼로리순</button>
      <FoodList items={sortedItems} />
    </div>
  );
}

export default App;
```

### ✅`.sort()`는 원본 배열을 **변경**함

```JSX
const sortedItems = items.sort((a, b) => b[order] - a[order]); 
// ❌ 원본 변형
```

- 이렇게 하면 `items` 자체가 바뀌기 때문에, **React state 관리에서 문제가 생길 수 있어요.**
- 해결법은 **복사 후 정렬**

```JSX
const sortedItems = [...items].sort((a, b) => b[order] - a[order]); 
// ✅ 안전
```


### 3. Filter

조건에 부합하는 요소만으로 새로 구성한 새 배열을 반환한다.

	배열.filter((item) => /*조건*/); 

**리액트 활용 예시**

```JSX
function App() {
  const [items, setItems] = useState(mockItems);
  const [order, setOrder] = useState('createdAt');

  const handleNewestClick = () => setOrder('createdAt');

  const handleCalorieClick = () => setOrder('calorie');

  const sortedItems = items.sort((a, b) => b[order] - a[order]);

  const handleDelete = (id) => {
    //id가 일치하지 않는 것으로만 새로 구성 = id번째 요소는 없앰.
    const nextItems = items.filter((item) => item.id !== id); 
    setItems(nextItems);
  };
  
  
  return (
    <div>
      <button onClick={handleNewestClick}>최신순</button>
      <button onClick={handleCalorieClick}>칼로리순</button>
      <FoodList items={sortedItems} onDelete={handleDelete}/>
    </div>
  );
}
```


### 4. Key

map, sort, filter는 모두 배열을 반환한다.
배열 렌더링으로 만들어진 React객체 하나하나에 접근하기 위해서는 ,
태그에 key 속성을 사전에 부여하면 된다.

```jSX
function FoodList({ items, onDelete }) {
  return (
    <ul className="FoodList">
      {items.map((item) => (
        <li key={item.id}>
          <FoodListItem item={item} onDelete={onDelete} />
        </li>
      ))}
    </ul>
  );
}
```

**<Key를 써야 하는 이유>**

1) key속성을 부여하지 않은 배열렌더링 컴포넌트를 만들면 경고메세지가 나온다.
2) key가 없어도 접근할 수는 있지만, 접근 속도가 느려진다.
3) Key가 있으면 배열이 변경되었을 때 수정 사항을 알기 쉽다.

![[Key 경고창.png]]
개발자 모드 경고창

![[배열렌더링Key.png]]


